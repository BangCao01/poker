{"ast":null,"code":"/*!\n * @pixi/interaction - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Point } from '@pixi/math';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { DisplayObject } from '@pixi/display';\nimport { EventEmitter } from '@pixi/utils';\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n * @memberof PIXI.interaction\n */\n\nvar InteractionData = function InteractionData() {\n  /**\n   * This point stores the global coords of where the touch/mouse event happened\n   *\n   * @member {PIXI.Point}\n   */\n  this.global = new Point();\n  /**\n   * The target Sprite that was interacted with\n   *\n   * @member {PIXI.Sprite}\n   */\n\n  this.target = null;\n  /**\n   * When passed to an event handler, this will be the original DOM Event that was captured\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n   * @member {MouseEvent|TouchEvent|PointerEvent}\n   */\n\n  this.originalEvent = null;\n  /**\n   * Unique identifier for this interaction\n   *\n   * @member {number}\n   */\n\n  this.identifier = null;\n  /**\n   * Indicates whether or not the pointer device that created the event is the primary pointer.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n   * @type {Boolean}\n   */\n\n  this.isPrimary = false;\n  /**\n   * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n   * @type {number}\n   */\n\n  this.button = 0;\n  /**\n   * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n   * @type {number}\n   */\n\n  this.buttons = 0;\n  /**\n   * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n   * radiusX of TouchEvents will be represented by this value.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n   * @type {number}\n   */\n\n  this.width = 0;\n  /**\n   * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n   * radiusY of TouchEvents will be represented by this value.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n   * @type {number}\n   */\n\n  this.height = 0;\n  /**\n   * The angle, in degrees, between the pointer device and the screen.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n   * @type {number}\n   */\n\n  this.tiltX = 0;\n  /**\n   * The angle, in degrees, between the pointer device and the screen.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n   * @type {number}\n   */\n\n  this.tiltY = 0;\n  /**\n   * The type of pointer that triggered the event.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n   * @type {string}\n   */\n\n  this.pointerType = null;\n  /**\n   * Pressure applied by the pointing device during the event. A Touch's force property\n   * will be represented by this value.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n   * @type {number}\n   */\n\n  this.pressure = 0;\n  /**\n   * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n   * @type {number}\n   */\n\n  this.rotationAngle = 0;\n  /**\n   * Twist of a stylus pointer.\n   * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n   * @type {number}\n   */\n\n  this.twist = 0;\n  /**\n   * Barrel pressure on a stylus pointer.\n   * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n   * @type {number}\n   */\n\n  this.tangentialPressure = 0;\n};\n\nvar prototypeAccessors = {\n  pointerId: {\n    configurable: true\n  }\n};\n/**\n * The unique identifier of the pointer. It will be the same as `identifier`.\n * @readonly\n * @member {number}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n */\n\nprototypeAccessors.pointerId.get = function () {\n  return this.identifier;\n};\n/**\n * This will return the local coordinates of the specified displayObject for this InteractionData\n *\n * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local\n *  coords off\n * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise\n *  will create a new point)\n * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional\n *  (otherwise will use the current global coords)\n * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative\n *  to the DisplayObject\n */\n\n\nInteractionData.prototype.getLocalPosition = function getLocalPosition(displayObject, point, globalPos) {\n  return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n};\n/**\n * Copies properties from normalized event data.\n *\n * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n */\n\n\nInteractionData.prototype.copyEvent = function copyEvent(event) {\n  // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n  // it with \"false\" on later events when our shim for it on touch events might not be\n  // accurate\n  if (event.isPrimary) {\n    this.isPrimary = true;\n  }\n\n  this.button = event.button; // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard\n  // event.which property instead, which conveys the same information.\n\n  this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;\n  this.width = event.width;\n  this.height = event.height;\n  this.tiltX = event.tiltX;\n  this.tiltY = event.tiltY;\n  this.pointerType = event.pointerType;\n  this.pressure = event.pressure;\n  this.rotationAngle = event.rotationAngle;\n  this.twist = event.twist || 0;\n  this.tangentialPressure = event.tangentialPressure || 0;\n};\n/**\n * Resets the data for pooling.\n */\n\n\nInteractionData.prototype.reset = function reset() {\n  // isPrimary is the only property that we really need to reset - everything else is\n  // guaranteed to be overwritten\n  this.isPrimary = false;\n};\n\nObject.defineProperties(InteractionData.prototype, prototypeAccessors);\n/**\n * Event class that mimics native DOM events.\n *\n * @class\n * @memberof PIXI.interaction\n */\n\nvar InteractionEvent = function InteractionEvent() {\n  /**\n   * Whether this event will continue propagating in the tree.\n   *\n   * Remaining events for the {@link stopsPropagatingAt} object\n   * will still be dispatched.\n   *\n   * @member {boolean}\n   */\n  this.stopped = false;\n  /**\n   * At which object this event stops propagating.\n   *\n   * @private\n   * @member {PIXI.DisplayObject}\n   */\n\n  this.stopsPropagatingAt = null;\n  /**\n   * Whether we already reached the element we want to\n   * stop propagating at. This is important for delayed events,\n   * where we start over deeper in the tree again.\n   *\n   * @private\n   * @member {boolean}\n   */\n\n  this.stopPropagationHint = false;\n  /**\n   * The object which caused this event to be dispatched.\n   * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.\n   *\n   * @member {PIXI.DisplayObject}\n   */\n\n  this.target = null;\n  /**\n   * The object whose event listenerâ€™s callback is currently being invoked.\n   *\n   * @member {PIXI.DisplayObject}\n   */\n\n  this.currentTarget = null;\n  /**\n   * Type of the event\n   *\n   * @member {string}\n   */\n\n  this.type = null;\n  /**\n   * InteractionData related to this event\n   *\n   * @member {PIXI.interaction.InteractionData}\n   */\n\n  this.data = null;\n};\n/**\n * Prevents event from reaching any objects other than the current object.\n *\n */\n\n\nInteractionEvent.prototype.stopPropagation = function stopPropagation() {\n  this.stopped = true;\n  this.stopPropagationHint = true;\n  this.stopsPropagatingAt = this.currentTarget;\n};\n/**\n * Resets the event.\n */\n\n\nInteractionEvent.prototype.reset = function reset() {\n  this.stopped = false;\n  this.stopsPropagatingAt = null;\n  this.stopPropagationHint = false;\n  this.currentTarget = null;\n  this.target = null;\n};\n/**\n * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions\n *\n * @class\n * @private\n * @memberof PIXI.interaction\n */\n\n\nvar InteractionTrackingData = function InteractionTrackingData(pointerId) {\n  this._pointerId = pointerId;\n  this._flags = InteractionTrackingData.FLAGS.NONE;\n};\n\nvar prototypeAccessors$1 = {\n  pointerId: {\n    configurable: true\n  },\n  flags: {\n    configurable: true\n  },\n  none: {\n    configurable: true\n  },\n  over: {\n    configurable: true\n  },\n  rightDown: {\n    configurable: true\n  },\n  leftDown: {\n    configurable: true\n  }\n};\n/**\n *\n * @private\n * @param {number} flag - The interaction flag to set\n * @param {boolean} yn - Should the flag be set or unset\n */\n\nInteractionTrackingData.prototype._doSet = function _doSet(flag, yn) {\n  if (yn) {\n    this._flags = this._flags | flag;\n  } else {\n    this._flags = this._flags & ~flag;\n  }\n};\n/**\n * Unique pointer id of the event\n *\n * @readonly\n * @private\n * @member {number}\n */\n\n\nprototypeAccessors$1.pointerId.get = function () {\n  return this._pointerId;\n};\n/**\n * State of the tracking data, expressed as bit flags\n *\n * @private\n * @member {number}\n */\n\n\nprototypeAccessors$1.flags.get = function () {\n  return this._flags;\n};\n\nprototypeAccessors$1.flags.set = function (flags) // eslint-disable-line require-jsdoc\n{\n  this._flags = flags;\n};\n/**\n * Is the tracked event inactive (not over or down)?\n *\n * @private\n * @member {number}\n */\n\n\nprototypeAccessors$1.none.get = function () {\n  return this._flags === this.constructor.FLAGS.NONE;\n};\n/**\n * Is the tracked event over the DisplayObject?\n *\n * @private\n * @member {boolean}\n */\n\n\nprototypeAccessors$1.over.get = function () {\n  return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n};\n\nprototypeAccessors$1.over.set = function (yn) // eslint-disable-line require-jsdoc\n{\n  this._doSet(this.constructor.FLAGS.OVER, yn);\n};\n/**\n * Did the right mouse button come down in the DisplayObject?\n *\n * @private\n * @member {boolean}\n */\n\n\nprototypeAccessors$1.rightDown.get = function () {\n  return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n};\n\nprototypeAccessors$1.rightDown.set = function (yn) // eslint-disable-line require-jsdoc\n{\n  this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n};\n/**\n * Did the left mouse button come down in the DisplayObject?\n *\n * @private\n * @member {boolean}\n */\n\n\nprototypeAccessors$1.leftDown.get = function () {\n  return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n};\n\nprototypeAccessors$1.leftDown.set = function (yn) // eslint-disable-line require-jsdoc\n{\n  this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n};\n\nObject.defineProperties(InteractionTrackingData.prototype, prototypeAccessors$1);\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2\n});\n/**\n * Strategy how to search through stage tree for interactive objects\n *\n * @private\n * @class\n * @memberof PIXI.interaction\n */\n\nvar TreeSearch = function TreeSearch() {\n  this._tempPoint = new Point();\n};\n/**\n * Recursive implementation for findHit\n *\n * @private\n * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n *  is tested for collision\n * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n *  that will be hit test (recursively crawls its children)\n * @param {Function} [func] - the function that will be called on each interactive object. The\n *  interactionEvent, displayObject and hit will be passed to the function\n * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n * @param {boolean} [interactive] - Whether the displayObject is interactive\n * @return {boolean} returns true if the displayObject hit the point\n */\n\n\nTreeSearch.prototype.recursiveFindHit = function recursiveFindHit(interactionEvent, displayObject, func, hitTest, interactive) {\n  if (!displayObject || !displayObject.visible) {\n    return false;\n  }\n\n  var point = interactionEvent.data.global; // Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^\n  //\n  // This function will now loop through all objects and then only hit test the objects it HAS\n  // to, not all of them. MUCH faster..\n  // An object will be hit test if the following is true:\n  //\n  // 1: It is interactive.\n  // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n  //\n  // As another little optimization once an interactive object has been hit we can carry on\n  // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n  // A final optimization is that an object is not hit test directly if a child has already been hit.\n\n  interactive = displayObject.interactive || interactive;\n  var hit = false;\n  var interactiveParent = interactive; // Flag here can set to false if the event is outside the parents hitArea or mask\n\n  var hitTestChildren = true; // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea\n  // There is also no longer a need to hitTest children.\n\n  if (displayObject.hitArea) {\n    if (hitTest) {\n      displayObject.worldTransform.applyInverse(point, this._tempPoint);\n\n      if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {\n        hitTest = false;\n        hitTestChildren = false;\n      } else {\n        hit = true;\n      }\n    }\n\n    interactiveParent = false;\n  } // If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.\n  // We still want to hitTestChildren, however, to ensure a mouseout can still be generated.\n  // https://github.com/pixijs/pixi.js/issues/5135\n  else if (displayObject._mask) {\n      if (hitTest) {\n        if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {\n          hitTest = false;\n        }\n      }\n    } // ** FREE TIP **! If an object is not interactive or has no buttons in it\n  // (such as a game scene!) set interactiveChildren to false for that displayObject.\n  // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.\n\n\n  if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {\n    var children = displayObject.children;\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n      var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);\n\n      if (childHit) {\n        // its a good idea to check if a child has lost its parent.\n        // this means it has been removed whilst looping so its best\n        if (!child.parent) {\n          continue;\n        } // we no longer need to hit test any more objects in this container as we we\n        // now know the parent has been hit\n\n\n        interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n        // interactive and not just the child of an interactive object.\n        // This means we no longer need to hit test anything else. We still need to run\n        // through all objects, but we don't need to perform any hit tests.\n\n        if (childHit) {\n          if (interactionEvent.target) {\n            hitTest = false;\n          }\n\n          hit = true;\n        }\n      }\n    }\n  } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n  if (interactive) {\n    // if we are hit testing (as in we have no hit any objects yet)\n    // We also don't need to worry about hit testing if once of the displayObjects children\n    // has already been hit - but only if it was interactive, otherwise we need to keep\n    // looking for an interactive child, just in case we hit one\n    if (hitTest && !interactionEvent.target) {\n      // already tested against hitArea if it is defined\n      if (!displayObject.hitArea && displayObject.containsPoint) {\n        if (displayObject.containsPoint(point)) {\n          hit = true;\n        }\n      }\n    }\n\n    if (displayObject.interactive) {\n      if (hit && !interactionEvent.target) {\n        interactionEvent.target = displayObject;\n      }\n\n      if (func) {\n        func(interactionEvent, displayObject, !!hit);\n      }\n    }\n  }\n\n  return hit;\n};\n/**\n * This function is provides a neat way of crawling through the scene graph and running a\n * specified function on all interactive objects it finds. It will also take care of hit\n * testing the interactive objects and passes the hit across in the function.\n *\n * @private\n * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n *  is tested for collision\n * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n *  that will be hit test (recursively crawls its children)\n * @param {Function} [func] - the function that will be called on each interactive object. The\n *  interactionEvent, displayObject and hit will be passed to the function\n * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n * @return {boolean} returns true if the displayObject hit the point\n */\n\n\nTreeSearch.prototype.findHit = function findHit(interactionEvent, displayObject, func, hitTest) {\n  this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);\n};\n/**\n * Interface for classes that represent a hit area.\n *\n * It is implemented by the following classes:\n * - {@link PIXI.Circle}\n * - {@link PIXI.Ellipse}\n * - {@link PIXI.Polygon}\n * - {@link PIXI.RoundedRectangle}\n *\n * @interface IHitArea\n * @memberof PIXI\n */\n\n/**\n * Checks whether the x and y coordinates given are contained within this area\n *\n * @method\n * @name contains\n * @memberof PIXI.IHitArea#\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this area\n */\n\n/**\n * Default property values of interactive objects\n * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties\n *\n * @private\n * @name interactiveTarget\n * @type {Object}\n * @memberof PIXI.interaction\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          DisplayObject.prototype,\n *          PIXI.interaction.interactiveTarget\n *      );\n */\n\n\nvar interactiveTarget = {\n  /**\n   * Enable interaction events for the DisplayObject. Touch, pointer and mouse\n   * events will not be emitted unless `interactive` is set to `true`.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.on('tap', (event) => {\n   *    //handle event\n   * });\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  interactive: false,\n\n  /**\n   * Determines if the children to the displayObject can be clicked/touched\n   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n   *\n   * @member {boolean}\n   * @memberof PIXI.Container#\n   */\n  interactiveChildren: true,\n\n  /**\n   * Interaction shape. Children will be hit first, then this shape will be checked.\n   * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);\n   * @member {PIXI.IHitArea}\n   * @memberof PIXI.DisplayObject#\n   */\n  hitArea: null,\n\n  /**\n   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n   * Setting this changes the 'cursor' property to `'pointer'`.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.buttonMode = true;\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  get buttonMode() {\n    return this.cursor === 'pointer';\n  },\n\n  set buttonMode(value) {\n    if (value) {\n      this.cursor = 'pointer';\n    } else if (this.cursor === 'pointer') {\n      this.cursor = null;\n    }\n  },\n\n  /**\n   * This defines what cursor mode is used when the mouse cursor\n   * is hovered over the displayObject.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.cursor = 'wait';\n   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n   *\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  cursor: null,\n\n  /**\n   * Internal set of all active pointers, by identifier\n   *\n   * @member {Map<number, InteractionTrackingData>}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   */\n  get trackedPointers() {\n    if (this._trackedPointers === undefined) {\n      this._trackedPointers = {};\n    }\n\n    return this._trackedPointers;\n  },\n\n  /**\n   * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n   *\n   * @private\n   * @type {Map<number, InteractionTrackingData>}\n   */\n  _trackedPointers: undefined\n}; // Mix interactiveTarget into DisplayObject.prototype,\n// after deprecation has been handled\n\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events.\n *\n * Any DisplayObject can be interactive if its `interactive` property is set to true.\n *\n * This manager also supports multitouch.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI.interaction\n */\n\nvar InteractionManager = /*@__PURE__*/function (EventEmitter) {\n  function InteractionManager(renderer, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {PIXI.AbstractRenderer}\n     */\n\n    this.renderer = renderer;\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n    /**\n     * Maximum requency in milliseconds at which pointer over/out states will be checked by {@link tickerUpdate}.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {PIXI.interaction.InteractionData}\n     */\n\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,PIXI.interaction.InteractionData>}\n     */\n\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {PIXI.interaction.InteractionData[]}\n     */\n\n    this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @protected\n     * @member {HTMLElement}\n     */\n\n    this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM version works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how PixiJS used to work. This will be set to true in\n     * future versions of pixi.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    this.moveWhenInside = false;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @protected\n     * @member {boolean}\n     */\n\n    this.eventsAdded = false;\n    /**\n     * Has the system ticker been added?\n     *\n     * @protected\n     * @member {boolean}\n     */\n\n    this.tickerAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @protected\n     * @member {boolean}\n     */\n\n    this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerOver = this.onPointerOver.bind(this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, Object>}\n     */\n\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    this.cursor = null;\n    /**\n     * The current resolution / device pixel ratio.\n     *\n     * @member {number}\n     * @default 1\n     */\n\n    this.resolution = 1;\n    /**\n     * Delayed pointer events. Used to guarantee correct ordering of over/out events.\n     *\n     * @private\n     * @member {Array}\n     */\n\n    this.delayedEvents = [];\n    /**\n     * TreeSearch component that is used to hitTest stage tree\n     *\n     * @private\n     * @member {PIXI.interaction.TreeSearch}\n     */\n\n    this.search = new TreeSearch();\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event PIXI.interaction.InteractionManager#mousedown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#rightdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event PIXI.interaction.InteractionManager#mouseup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#rightup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#click\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#rightclick\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown}.\n     *\n     * @event PIXI.interaction.InteractionManager#mouseupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link PIXI.interaction.InteractionManager#event:rightdown}.\n     *\n     * @event PIXI.interaction.InteractionManager#rightupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event PIXI.interaction.InteractionManager#mousemove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event PIXI.interaction.InteractionManager#mouseover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event PIXI.interaction.InteractionManager#mouseout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#pointerdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * Not always fired when some buttons are held down while others are released. In those cases,\n     * use [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown} and\n     * [mouseup]{@link PIXI.interaction.InteractionManager#event:mouseup} instead.\n     *\n     * @event PIXI.interaction.InteractionManager#pointerup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event PIXI.interaction.InteractionManager#pointercancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#pointertap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link PIXI.interaction.InteractionManager#event:pointerdown}.\n     *\n     * @event PIXI.interaction.InteractionManager#pointerupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event PIXI.interaction.InteractionManager#pointermove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event PIXI.interaction.InteractionManager#pointerover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event PIXI.interaction.InteractionManager#pointerout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#touchstart\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#touchend\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event PIXI.interaction.InteractionManager#touchcancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#tap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link PIXI.interaction.InteractionManager#event:touchstart}.\n     *\n     * @event PIXI.interaction.InteractionManager#touchendoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#touchmove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mousedown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#click\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightclick\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mousemove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointercancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointertap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointermove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchstart\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchend\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchcancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#tap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchendoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchmove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    this._useSystemTicker = options.useSystemTicker !== undefined ? options.useSystemTicker : true;\n    this.setTargetElement(this.renderer.view, this.renderer.resolution);\n  }\n\n  if (EventEmitter) InteractionManager.__proto__ = EventEmitter;\n  InteractionManager.prototype = Object.create(EventEmitter && EventEmitter.prototype);\n  InteractionManager.prototype.constructor = InteractionManager;\n  var prototypeAccessors = {\n    useSystemTicker: {\n      configurable: true\n    }\n  };\n  /**\n   * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n   *\n   * @member {boolean}\n   * @default true\n   */\n\n  prototypeAccessors.useSystemTicker.get = function () {\n    return this._useSystemTicker;\n  };\n\n  prototypeAccessors.useSystemTicker.set = function (useSystemTicker) {\n    this._useSystemTicker = useSystemTicker;\n\n    if (useSystemTicker) {\n      this.addTickerListener();\n    } else {\n      this.removeTickerListener();\n    }\n  };\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.\n   * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {PIXI.DisplayObject} The hit display object, if any.\n   */\n\n\n  InteractionManager.prototype.hitTest = function hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null; // assign the global point\n\n    hitTestEvent.data.global = globalPoint; // ensure safety of the root\n\n    if (!root) {\n      root = this.renderer._lastObjectRendered;\n    } // run the hit test\n\n\n    this.processInteractive(hitTestEvent, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  };\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLElement} element - the DOM element which will receive mouse and touch events.\n   * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).\n   */\n\n\n  InteractionManager.prototype.setTargetElement = function setTargetElement(element, resolution) {\n    if (resolution === void 0) resolution = 1;\n    this.removeTickerListener();\n    this.removeEvents();\n    this.interactionDOMElement = element;\n    this.resolution = resolution;\n    this.addEvents();\n    this.addTickerListener();\n  };\n  /**\n   * Add the ticker listener\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.addTickerListener = function addTickerListener() {\n    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {\n      return;\n    }\n\n    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n    this.tickerAdded = true;\n  };\n  /**\n   * Remove the ticker listener\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.removeTickerListener = function removeTickerListener() {\n    if (!this.tickerAdded) {\n      return;\n    }\n\n    Ticker.system.remove(this.tickerUpdate, this);\n    this.tickerAdded = false;\n  };\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.addEvents = function addEvents() {\n    if (this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n    /**\n     * These events are added first, so that if pointer events are normalized, they are fired\n     * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n     */\n\n\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    } // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  };\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.removeEvents = function removeEvents() {\n    if (!this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n    this.eventsAdded = false;\n  };\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n   *\n   * @param {number} deltaTime - time delta since the last call\n   */\n\n\n  InteractionManager.prototype.tickerUpdate = function tickerUpdate(deltaTime) {\n    this._deltaTime += deltaTime;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n    this.update();\n  };\n  /**\n   * Updates the state of interactive objects.\n   */\n\n\n  InteractionManager.prototype.update = function update() {\n    if (!this.interactionDOMElement) {\n      return;\n    } // if the user move the mouse this check has already been done using the mouse move!\n\n\n    if (this.didMove) {\n      this.didMove = false;\n      return;\n    }\n\n    this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function\n\n    for (var k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        var interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n          this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n  };\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n\n\n  InteractionManager.prototype.setCursorMode = function setCursorMode(mode) {\n    mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n\n    this.currentCursorMode = mode;\n    var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  };\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n\n\n  InteractionManager.prototype.dispatchEvent = function dispatchEvent(displayObject, eventString, eventData) {\n    // Even if the event was stopped, at least dispatch any remaining events\n    // for the same display object.\n    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  };\n  /**\n   * Puts a event on a queue to be dispatched later. This is used to guarantee correct\n   * ordering of over/out events.\n   *\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n\n\n  InteractionManager.prototype.delayDispatchEvent = function delayDispatchEvent(displayObject, eventString, eventData) {\n    this.delayedEvents.push({\n      displayObject: displayObject,\n      eventString: eventString,\n      eventData: eventData\n    });\n  };\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {PIXI.Point} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n\n\n  InteractionManager.prototype.mapPositionToPoint = function mapPositionToPoint(point, x, y) {\n    var rect; // IE 11 fix\n\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    var resolutionMultiplier = 1.0 / this.resolution;\n    point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;\n  };\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @protected\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - indicates whether we want to calculate hits\n   *  or just iterate through all interactive objects\n   */\n\n\n  InteractionManager.prototype.processInteractive = function processInteractive(interactionEvent, displayObject, func, hitTest) {\n    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);\n    var delayedEvents = this.delayedEvents;\n\n    if (!delayedEvents.length) {\n      return hit;\n    } // Reset the propagation hint, because we start deeper in the tree again.\n\n\n    interactionEvent.stopPropagationHint = false;\n    var delayedLen = delayedEvents.length;\n    this.delayedEvents = [];\n\n    for (var i = 0; i < delayedLen; i++) {\n      var ref = delayedEvents[i];\n      var displayObject$1 = ref.displayObject;\n      var eventString = ref.eventString;\n      var eventData = ref.eventData; // When we reach the object we wanted to stop propagating at,\n      // set the propagation hint.\n\n      if (eventData.stopsPropagatingAt === displayObject$1) {\n        eventData.stopPropagationHint = true;\n      }\n\n      this.dispatchEvent(displayObject$1, eventString, eventData);\n    }\n\n    return hit;\n  };\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n\n\n  InteractionManager.prototype.onPointerDown = function onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n\n    var events = this.normalizeToPointerData(originalEvent);\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      var cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);\n\n      if (cancelable) {\n        originalEvent.preventDefault();\n      }\n    }\n\n    var eventLen = events.length;\n\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);\n      this.emit('pointerdown', interactionEvent);\n\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } // emit a mouse event for \"pen\" pointers, the way a browser would emit a fallback event\n      else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n    }\n  };\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerDown = function processPointerDown(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.dispatchEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        var isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n\n\n  InteractionManager.prototype.onPointerComplete = function onPointerComplete(originalEvent, cancelled, func) {\n    var events = this.normalizeToPointerData(originalEvent);\n    var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n\n    var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n      this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);\n      this.emit(cancelled ? 'pointercancel' : \"pointerup\" + eventAppend, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        var isRightButton = event.button === 2;\n        this.emit(isRightButton ? \"rightup\" + eventAppend : \"mouseup\" + eventAppend, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : \"touchend\" + eventAppend, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n\n\n  InteractionManager.prototype.onPointerCancel = function onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') {\n      return;\n    }\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  };\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   */\n\n\n  InteractionManager.prototype.processPointerCancel = function processPointerCancel(interactionEvent, displayObject) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n\n\n  InteractionManager.prototype.onPointerUp = function onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') {\n      return;\n    }\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  };\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerUp = function processPointerUp(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var trackingData = displayObject.trackedPointers[id];\n    var isTouch = data.pointerType === 'touch';\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // need to track mouse down status in the mouse block so that we can emit\n    // event in a later block\n\n    var isMouseTap = false; // Mouse only\n\n    if (isMouse) {\n      var isRightButton = data.button === 2;\n      var flags = InteractionTrackingData.FLAGS;\n      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n      var isDown = trackingData !== undefined && trackingData.flags & test;\n\n      if (hit) {\n        this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent); // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap\n\n          isMouseTap = true;\n        }\n      } else if (isDown) {\n        this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      } // update the down state of the tracking data\n\n\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    } // Pointers and Touches, and Mouse\n\n\n    if (hit) {\n      this.dispatchEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (trackingData) {\n        // emit pointertap if not a mouse, or if the mouse block decided it was a tap\n        if (!isMouse || isMouseTap) {\n          this.dispatchEvent(displayObject, 'pointertap', interactionEvent);\n        }\n\n        if (isTouch) {\n          this.dispatchEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);\n\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);\n      }\n    } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  };\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n\n\n  InteractionManager.prototype.onPointerMove = function onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n\n    var events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {\n      this.didMove = true;\n      this.cursor = null;\n    }\n\n    var eventLen = events.length;\n\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, true);\n      this.emit('pointermove', interactionEvent);\n\n      if (event.pointerType === 'touch') {\n        this.emit('touchmove', interactionEvent);\n      }\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mousemove', interactionEvent);\n      }\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n    }\n  };\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerMove = function processPointerMove(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var isTouch = data.pointerType === 'touch';\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (!this.moveWhenInside || hit) {\n      this.dispatchEvent(displayObject, 'pointermove', interactionEvent);\n\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchmove', interactionEvent);\n      }\n\n      if (isMouse) {\n        this.dispatchEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n\n\n  InteractionManager.prototype.onPointerOut = function onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n\n    var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n    var event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n    this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);\n    this.emit('pointerout', interactionEvent);\n\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  };\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerOverOut = function processPointerOverOut(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n    var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) {\n      return;\n    }\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.delayDispatchEvent(displayObject, 'pointerover', interactionEvent);\n\n        if (isMouse) {\n          this.delayDispatchEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      } // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n\n\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.dispatchEvent(displayObject, 'pointerout', this.eventData);\n\n      if (isMouse) {\n        this.dispatchEvent(displayObject, 'mouseout', interactionEvent);\n      } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  };\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n\n\n  InteractionManager.prototype.onPointerOver = function onPointerOver(originalEvent) {\n    var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n    var event = events[0];\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  };\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {PIXI.interaction.InteractionData} - Interaction data for the given pointer identifier\n   */\n\n\n  InteractionManager.prototype.getInteractionDataForPointerId = function getInteractionDataForPointerId(event) {\n    var pointerId = event.pointerId;\n    var interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    } // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n\n\n    interactionData.copyEvent(event);\n    return interactionData;\n  };\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n\n\n  InteractionManager.prototype.releaseInteractionDataForPointerId = function releaseInteractionDataForPointerId(pointerId) {\n    var interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData.reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  };\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {PIXI.interaction.InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {PIXI.interaction.InteractionEvent} the interaction event that was passed in\n   */\n\n\n  InteractionManager.prototype.configureInteractionEventForDOMEvent = function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY); // Not really sure why this is happening, but it's how a previous version handled things\n\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent.reset();\n    return interactionEvent;\n  };\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n\n\n  InteractionManager.prototype.normalizeToPointerData = function normalizeToPointerData(event) {\n    var normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n        var touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') {\n          touch.button = event.touches.length ? 1 : 0;\n        }\n\n        if (typeof touch.buttons === 'undefined') {\n          touch.buttons = event.touches.length ? 1 : 0;\n        }\n\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n\n        if (typeof touch.width === 'undefined') {\n          touch.width = touch.radiusX || 1;\n        }\n\n        if (typeof touch.height === 'undefined') {\n          touch.height = touch.radiusY || 1;\n        }\n\n        if (typeof touch.tiltX === 'undefined') {\n          touch.tiltX = 0;\n        }\n\n        if (typeof touch.tiltY === 'undefined') {\n          touch.tiltY = 0;\n        }\n\n        if (typeof touch.pointerType === 'undefined') {\n          touch.pointerType = 'touch';\n        }\n\n        if (typeof touch.pointerId === 'undefined') {\n          touch.pointerId = touch.identifier || 0;\n        }\n\n        if (typeof touch.pressure === 'undefined') {\n          touch.pressure = touch.force || 0.5;\n        }\n\n        if (typeof touch.twist === 'undefined') {\n          touch.twist = 0;\n        }\n\n        if (typeof touch.tangentialPressure === 'undefined') {\n          touch.tangentialPressure = 0;\n        } // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n\n\n        if (typeof touch.layerX === 'undefined') {\n          touch.layerX = touch.offsetX = touch.clientX;\n        }\n\n        if (typeof touch.layerY === 'undefined') {\n          touch.layerY = touch.offsetY = touch.clientY;\n        } // mark the touch as normalized, just so that we know we did it\n\n\n        touch.isNormalized = true;\n        normalizedEvents.push(touch);\n      }\n    } // apparently PointerEvent subclasses MouseEvent, so yay\n    else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') {\n          event.isPrimary = true;\n        }\n\n        if (typeof event.width === 'undefined') {\n          event.width = 1;\n        }\n\n        if (typeof event.height === 'undefined') {\n          event.height = 1;\n        }\n\n        if (typeof event.tiltX === 'undefined') {\n          event.tiltX = 0;\n        }\n\n        if (typeof event.tiltY === 'undefined') {\n          event.tiltY = 0;\n        }\n\n        if (typeof event.pointerType === 'undefined') {\n          event.pointerType = 'mouse';\n        }\n\n        if (typeof event.pointerId === 'undefined') {\n          event.pointerId = MOUSE_POINTER_ID;\n        }\n\n        if (typeof event.pressure === 'undefined') {\n          event.pressure = 0.5;\n        }\n\n        if (typeof event.twist === 'undefined') {\n          event.twist = 0;\n        }\n\n        if (typeof event.tangentialPressure === 'undefined') {\n          event.tangentialPressure = 0;\n        } // mark the mouse event as normalized, just so that we know we did it\n\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n    return normalizedEvents;\n  };\n  /**\n   * Destroys the interaction manager\n   *\n   */\n\n\n  InteractionManager.prototype.destroy = function destroy() {\n    this.removeEvents();\n    this.removeTickerListener();\n    this.removeAllListeners();\n    this.renderer = null;\n    this.mouse = null;\n    this.eventData = null;\n    this.interactionDOMElement = null;\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n    this.onPointerOver = null;\n    this.search = null;\n  };\n\n  Object.defineProperties(InteractionManager.prototype, prototypeAccessors);\n  return InteractionManager;\n}(EventEmitter);\n/**\n * This namespace contains a renderer plugin for handling mouse, pointer, and touch events.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @namespace PIXI.interaction\n */\n\n\nexport { InteractionData, InteractionEvent, InteractionManager, InteractionTrackingData, interactiveTarget };","map":null,"metadata":{},"sourceType":"module"}