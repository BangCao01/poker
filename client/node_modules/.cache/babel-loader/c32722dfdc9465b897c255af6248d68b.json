{"ast":null,"code":"/*!\n * @pixi/sprite-animated - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * let alienImages = [\"image_sequence_01.png\",\"image_sequence_02.png\",\"image_sequence_03.png\",\"image_sequence_04.png\"];\n * let textureArray = [];\n *\n * for (let i=0; i < 4; i++)\n * {\n *      let texture = PIXI.Texture.from(alienImages[i]);\n *      textureArray.push(texture);\n * };\n *\n * let animatedSprite = new PIXI.AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}\n * containing the animation definitions:\n *\n * ```js\n * PIXI.Loader.shared.add(\"assets/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"assets/spritesheet.json\"].spritesheet;\n *   animatedSprite = new PIXI.AnimatedSprite(sheet.animations[\"image_sequence\"]);\n *   ...\n * }\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\n\nvar AnimatedSprite = /*@__PURE__*/function (Sprite) {\n  function AnimatedSprite(textures, autoUpdate) {\n    Sprite.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n    /**\n     * @type {PIXI.Texture[]}\n     * @private\n     */\n\n    this._textures = null;\n    /**\n     * @type {number[]}\n     * @private\n     */\n\n    this._durations = null;\n    this.textures = textures;\n    /**\n     * `true` uses PIXI.Ticker.shared to auto update animation time.\n     * @type {boolean}\n     * @default true\n     * @private\n     */\n\n    this._autoUpdate = autoUpdate !== false;\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     *\n     * @member {number}\n     * @default 1\n     */\n\n    this.animationSpeed = 1;\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    this.loop = true;\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    this.updateAnchor = false;\n    /**\n     * Function to call when an AnimatedSprite finishes playing.\n     *\n     * @member {Function}\n     */\n\n    this.onComplete = null;\n    /**\n     * Function to call when an AnimatedSprite changes which texture is being rendered.\n     *\n     * @member {Function}\n     */\n\n    this.onFrameChange = null;\n    /**\n     * Function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again.\n     *\n     * @member {Function}\n     */\n\n    this.onLoop = null;\n    /**\n     * Elapsed time since animation has been started, used internally to display current texture.\n     *\n     * @member {number}\n     * @private\n     */\n\n    this._currentTime = 0;\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n\n    this.playing = false;\n  }\n\n  if (Sprite) AnimatedSprite.__proto__ = Sprite;\n  AnimatedSprite.prototype = Object.create(Sprite && Sprite.prototype);\n  AnimatedSprite.prototype.constructor = AnimatedSprite;\n  var prototypeAccessors = {\n    totalFrames: {\n      configurable: true\n    },\n    textures: {\n      configurable: true\n    },\n    currentFrame: {\n      configurable: true\n    }\n  };\n  /**\n   * Stops the AnimatedSprite.\n   *\n   */\n\n  AnimatedSprite.prototype.stop = function stop() {\n    if (!this.playing) {\n      return;\n    }\n\n    this.playing = false;\n\n    if (this._autoUpdate) {\n      Ticker.shared.remove(this.update, this);\n    }\n  };\n  /**\n   * Plays the AnimatedSprite.\n   *\n   */\n\n\n  AnimatedSprite.prototype.play = function play() {\n    if (this.playing) {\n      return;\n    }\n\n    this.playing = true;\n\n    if (this._autoUpdate) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n    }\n  };\n  /**\n   * Stops the AnimatedSprite and goes to a specific frame.\n   *\n   * @param {number} frameNumber - Frame index to stop at.\n   */\n\n\n  AnimatedSprite.prototype.gotoAndStop = function gotoAndStop(frameNumber) {\n    this.stop();\n    var previousFrame = this.currentFrame;\n    this._currentTime = frameNumber;\n\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n  };\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite.\n   *\n   * @param {number} frameNumber - Frame index to start at.\n   */\n\n\n  AnimatedSprite.prototype.gotoAndPlay = function gotoAndPlay(frameNumber) {\n    var previousFrame = this.currentFrame;\n    this._currentTime = frameNumber;\n\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n\n    this.play();\n  };\n  /**\n   * Updates the object transform for rendering.\n   *\n   * @private\n   * @param {number} deltaTime - Time since last tick.\n   */\n\n\n  AnimatedSprite.prototype.update = function update(deltaTime) {\n    var elapsed = this.animationSpeed * deltaTime;\n    var previousFrame = this.currentFrame;\n\n    if (this._durations !== null) {\n      var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1000;\n\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n\n      var sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n\n    if (this._currentTime < 0 && !this.loop) {\n      this._currentTime = 0;\n      this.stop();\n\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this._currentTime = this._textures.length - 1;\n      this.stop();\n\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {\n          this.onLoop();\n        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n\n      this.updateTexture();\n    }\n  };\n  /**\n   * Updates the displayed texture to match the current frame index.\n   *\n   * @private\n   */\n\n\n  AnimatedSprite.prototype.updateTexture = function updateTexture() {\n    this._texture = this._textures[this.currentFrame];\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 0xFFFFFF;\n    this.uvs = this._texture._uvs.uvsFloat32;\n\n    if (this.updateAnchor) {\n      this._anchor.copyFrom(this._texture.defaultAnchor);\n    }\n\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  };\n  /**\n   * Stops the AnimatedSprite and destroys it.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.\n   */\n\n\n  AnimatedSprite.prototype.destroy = function destroy(options) {\n    this.stop();\n    Sprite.prototype.destroy.call(this, options);\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  };\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   *\n   * @static\n   * @param {string[]} frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n   * @return {AnimatedSprite} The new animated sprite with the specified frames.\n   */\n\n\n  AnimatedSprite.fromFrames = function fromFrames(frames) {\n    var textures = [];\n\n    for (var i = 0; i < frames.length; ++i) {\n      textures.push(Texture.from(frames[i]));\n    }\n\n    return new AnimatedSprite(textures);\n  };\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image ids.\n   *\n   * @static\n   * @param {string[]} images - The array of image urls the AnimatedSprite will use as its texture frames.\n   * @return {AnimatedSprite} The new animate sprite with the specified images as frames.\n   */\n\n\n  AnimatedSprite.fromImages = function fromImages(images) {\n    var textures = [];\n\n    for (var i = 0; i < images.length; ++i) {\n      textures.push(Texture.from(images[i]));\n    }\n\n    return new AnimatedSprite(textures);\n  };\n  /**\n   * The total number of frames in the AnimatedSprite. This is the same as number of textures\n   * assigned to the AnimatedSprite.\n   *\n   * @readonly\n   * @member {number}\n   * @default 0\n   */\n\n\n  prototypeAccessors.totalFrames.get = function () {\n    return this._textures.length;\n  };\n  /**\n   * The array of textures used for this AnimatedSprite.\n   *\n   * @member {PIXI.Texture[]}\n   */\n\n\n  prototypeAccessors.textures.get = function () {\n    return this._textures;\n  };\n\n  prototypeAccessors.textures.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    if (value[0] instanceof Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n\n      for (var i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n\n        this._durations.push(value[i].time);\n      }\n    }\n\n    this.gotoAndStop(0);\n    this.updateTexture();\n  };\n  /**\n  * The AnimatedSprites current frame index.\n  *\n  * @member {number}\n  * @readonly\n  */\n\n\n  prototypeAccessors.currentFrame.get = function () {\n    var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n\n    return currentFrame;\n  };\n\n  Object.defineProperties(AnimatedSprite.prototype, prototypeAccessors);\n  return AnimatedSprite;\n}(Sprite);\n/**\n * @memberof PIXI.AnimatedSprite\n * @typedef {object} FrameObject\n * @type {object}\n * @property {PIXI.Texture} texture - The {@link PIXI.Texture} of the frame\n * @property {number} time - the duration of the frame in ms\n */\n\n\nexport { AnimatedSprite };","map":null,"metadata":{},"sourceType":"module"}